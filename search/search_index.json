{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"your your stands for Your Unified Reader. This library reads sigproc filterbanks, psrfits, and psrdada formats and can go from one format to another. Format Read Write filterbank psrfits psrdada The inspiration for the name comes from the Daily Dose of Internet videos . Installation First you need to install psrdada-python . Once psrdada is installed, git clone the repo and use setup.py to install your . git clone https://github.com/devanshkv/your.git cd your python setup.py install Have a look at our docs for the basic documentation. We will add detail shortly.","title":"your"},{"location":"#your","text":"your stands for Your Unified Reader. This library reads sigproc filterbanks, psrfits, and psrdada formats and can go from one format to another. Format Read Write filterbank psrfits psrdada The inspiration for the name comes from the Daily Dose of Internet videos .","title":"your"},{"location":"#installation","text":"First you need to install psrdada-python . Once psrdada is installed, git clone the repo and use setup.py to install your . git clone https://github.com/devanshkv/your.git cd your python setup.py install Have a look at our docs for the basic documentation. We will add detail shortly.","title":"Installation"},{"location":"candidate/","text":"Candidate class your . candidate . Candidate ( fp = None , dm = None , tcand = 0 , width = 0 , label =- 1 , snr = 0 , min_samp = 256 , device = 0 , kill_mask = None ) Candidate Class Args: fp : String or a list of files. It can either filterbank or psrfits files. dm (float): Dispersion Measure of the candidate tcand (float): start time of the candidate in seconds width (int): pulse width of the candidate in samples label (int): 1 for pulsars/FRBs, 0 for RFI snr (float): Signal to Noise Ratio min_samp (int): Minimum number of time samples device (int): GPU ID if using GPUs kill_mask (numpy.ndarray): Boolean mask of channels to kill save_h5 method Candidate . save_h5 ( out_dir = None , fnout = None ) Save the candidate to a hdf5 file Args: out_dir (str): path to the output directory fnout (str): output name of the file Returns: str: output name of the file dispersion_delay method Candidate . dispersion_delay ( dms = None ) Caluclaute the dispersion delay for the candidate DM or at given dispersion DM Args: dms (Union[float,np.ndarray]) : DM or a list of DMs Returns: Union[float, np.ndarray]: dispersion delay in seconds get_chunk method Candidate . get_chunk ( tstart = None , tstop = None ) Get a chunk of data. The data is saved in self.data . Args: tstart (float): start time of the chunk in seconds tstop (float): stop time of the chunk in secons dedisperse method Candidate . dedisperse ( dms = None , target = \"CPU\" ) Dedisperse a chunk of data. Saves the dedispersed chunk in self.dedispersed . Args: dms (float): The DM to dedisperse the data at. target (str): 'CPU' to run the code on the CPU or 'GPU' to run it on a GPU. dedispersets method Candidate . dedispersets ( dms = None ) Create a dedispersed time series Args: dms (float): The DM to dedisperse the data at. Returns: numpy.ndarray: Dedispersed time series. dmtime method Candidate . dmtime ( dmsteps = 256 , target = \"CPU\" ) Generates DM-time array of the candidate by dedispersing at adjacent DM values. Saves the data in self.dmt . Args: dmsteps (int) : Number of DMs to dedisperse at. target (str): 'CPU' to run the code on the CPU or 'GPU' to run it on a GPU. get_snr method Candidate . get_snr ( time_series = None ) Calculates the SNR of the candidate Args: time_series: time series array to calculate the SNR of Returns: float: SNR optimize_dm method Candidate . optimize_dm () Calculate more precise value of the DM by interpolating between DM values to maximise the SNR Note: This function has not been fully tested. Returns: optimnised DM, optimised SNR decimate method Candidate . decimate ( key , decimate_factor , axis , pad = False , ** kwargs ) Decimate FT or DMT data. Todo: * Update candidate parameters as per decimation factor Args: key (str): Keywords to chose which data to decimate ('dmt' or 'ft') decimate_factor (int): Number of samples to average axis (int): Axis to decimate along pad (bool): Optional argument if padding is to be done **kwargs: kwargs for numpy.pad resize method Candidate . resize ( key , size , axis , ** kwargs ) Resize FT or DMT data Todo: * Update candidate parameters as per final size Args: key (str): Keywords to chose which data to resize ('dmt' or 'ft') size: Final size of the data array required axis (int) : Axis to resize alone **kwargs: Arguments for skimage.transform resize function","title":"Candidate"},{"location":"candidate/#candidate-class","text":"your . candidate . Candidate ( fp = None , dm = None , tcand = 0 , width = 0 , label =- 1 , snr = 0 , min_samp = 256 , device = 0 , kill_mask = None ) Candidate Class Args: fp : String or a list of files. It can either filterbank or psrfits files. dm (float): Dispersion Measure of the candidate tcand (float): start time of the candidate in seconds width (int): pulse width of the candidate in samples label (int): 1 for pulsars/FRBs, 0 for RFI snr (float): Signal to Noise Ratio min_samp (int): Minimum number of time samples device (int): GPU ID if using GPUs kill_mask (numpy.ndarray): Boolean mask of channels to kill","title":"Candidate class"},{"location":"candidate/#save_h5-method","text":"Candidate . save_h5 ( out_dir = None , fnout = None ) Save the candidate to a hdf5 file Args: out_dir (str): path to the output directory fnout (str): output name of the file Returns: str: output name of the file","title":"save_h5 method"},{"location":"candidate/#dispersion_delay-method","text":"Candidate . dispersion_delay ( dms = None ) Caluclaute the dispersion delay for the candidate DM or at given dispersion DM Args: dms (Union[float,np.ndarray]) : DM or a list of DMs Returns: Union[float, np.ndarray]: dispersion delay in seconds","title":"dispersion_delay method"},{"location":"candidate/#get_chunk-method","text":"Candidate . get_chunk ( tstart = None , tstop = None ) Get a chunk of data. The data is saved in self.data . Args: tstart (float): start time of the chunk in seconds tstop (float): stop time of the chunk in secons","title":"get_chunk method"},{"location":"candidate/#dedisperse-method","text":"Candidate . dedisperse ( dms = None , target = \"CPU\" ) Dedisperse a chunk of data. Saves the dedispersed chunk in self.dedispersed . Args: dms (float): The DM to dedisperse the data at. target (str): 'CPU' to run the code on the CPU or 'GPU' to run it on a GPU.","title":"dedisperse method"},{"location":"candidate/#dedispersets-method","text":"Candidate . dedispersets ( dms = None ) Create a dedispersed time series Args: dms (float): The DM to dedisperse the data at. Returns: numpy.ndarray: Dedispersed time series.","title":"dedispersets method"},{"location":"candidate/#dmtime-method","text":"Candidate . dmtime ( dmsteps = 256 , target = \"CPU\" ) Generates DM-time array of the candidate by dedispersing at adjacent DM values. Saves the data in self.dmt . Args: dmsteps (int) : Number of DMs to dedisperse at. target (str): 'CPU' to run the code on the CPU or 'GPU' to run it on a GPU.","title":"dmtime method"},{"location":"candidate/#get_snr-method","text":"Candidate . get_snr ( time_series = None ) Calculates the SNR of the candidate Args: time_series: time series array to calculate the SNR of Returns: float: SNR","title":"get_snr method"},{"location":"candidate/#optimize_dm-method","text":"Candidate . optimize_dm () Calculate more precise value of the DM by interpolating between DM values to maximise the SNR Note: This function has not been fully tested. Returns: optimnised DM, optimised SNR","title":"optimize_dm method"},{"location":"candidate/#decimate-method","text":"Candidate . decimate ( key , decimate_factor , axis , pad = False , ** kwargs ) Decimate FT or DMT data. Todo: * Update candidate parameters as per decimation factor Args: key (str): Keywords to chose which data to decimate ('dmt' or 'ft') decimate_factor (int): Number of samples to average axis (int): Axis to decimate along pad (bool): Optional argument if padding is to be done **kwargs: kwargs for numpy.pad","title":"decimate method"},{"location":"candidate/#resize-method","text":"Candidate . resize ( key , size , axis , ** kwargs ) Resize FT or DMT data Todo: * Update candidate parameters as per final size Args: key (str): Keywords to chose which data to resize ('dmt' or 'ft') size: Final size of the data array required axis (int) : Axis to resize alone **kwargs: Arguments for skimage.transform resize function","title":"resize method"},{"location":"psrdada/","text":"DadaManager class your . dada . DadaManager ( size , key = 56026 , n_readers = 1 ) A manager class for psrdada writer. Args: size (int): size of each buffer (in bytes) key (hex): hexadecimal dada key n_readers (int): Number of dada readers. setup method DadaManager . setup () Kill any previous buffers with the same key. Set up the dada buffers and connect to a writer. dump_header method DadaManager . dump_header ( header ) Set the psrdada header dump_data method DadaManager . dump_data ( data_input ) Dump the data to the buffer Args: data_input (numpy.ndarray): Numpy array of the data. mark_filled method DadaManager . mark_filled () Mark that data is filled in the buffer page. eod method DadaManager . eod () Mark the end of data. teardown method DadaManager . teardown () Disconnect the writer and tear down the buffers. YourDada class your . dada . YourDada ( your_object ) Linker class between psrdada and your . Args: your_object: your object setup method YourDada . setup () Start the dada manager and make the header. teardown method YourDada . teardown () Tear down the dada header. your_dada_header method YourDada . your_dada_header () Make dada header from your_header . Returns: dict: dada header as a python dictionary. to_dada method YourDada . to_dada ( progress = None ) Dump the data to the dada buffer Args: progress: if `False` will not show the progress bar.","title":"psrdada"},{"location":"psrdada/#dadamanager-class","text":"your . dada . DadaManager ( size , key = 56026 , n_readers = 1 ) A manager class for psrdada writer. Args: size (int): size of each buffer (in bytes) key (hex): hexadecimal dada key n_readers (int): Number of dada readers.","title":"DadaManager class"},{"location":"psrdada/#setup-method","text":"DadaManager . setup () Kill any previous buffers with the same key. Set up the dada buffers and connect to a writer.","title":"setup method"},{"location":"psrdada/#dump_header-method","text":"DadaManager . dump_header ( header ) Set the psrdada header","title":"dump_header method"},{"location":"psrdada/#dump_data-method","text":"DadaManager . dump_data ( data_input ) Dump the data to the buffer Args: data_input (numpy.ndarray): Numpy array of the data.","title":"dump_data method"},{"location":"psrdada/#mark_filled-method","text":"DadaManager . mark_filled () Mark that data is filled in the buffer page.","title":"mark_filled method"},{"location":"psrdada/#eod-method","text":"DadaManager . eod () Mark the end of data.","title":"eod method"},{"location":"psrdada/#teardown-method","text":"DadaManager . teardown () Disconnect the writer and tear down the buffers.","title":"teardown method"},{"location":"psrdada/#yourdada-class","text":"your . dada . YourDada ( your_object ) Linker class between psrdada and your . Args: your_object: your object","title":"YourDada class"},{"location":"psrdada/#setup-method_1","text":"YourDada . setup () Start the dada manager and make the header.","title":"setup method"},{"location":"psrdada/#teardown-method_1","text":"YourDada . teardown () Tear down the dada header.","title":"teardown method"},{"location":"psrdada/#your_dada_header-method","text":"YourDada . your_dada_header () Make dada header from your_header . Returns: dict: dada header as a python dictionary.","title":"your_dada_header method"},{"location":"psrdada/#to_dada-method","text":"YourDada . to_dada ( progress = None ) Dump the data to the dada buffer Args: progress: if `False` will not show the progress bar.","title":"to_dada method"},{"location":"pysigproc/","text":"SigprocFile class your . pysigproc . SigprocFile ( fp = None , copy_hdr = None ) Simple functions for reading sigproc filterbank files from python. Not all possible features are implemented. Original Source from Paul Demorest's pysigproc.py . Args: fp (str): file name copy_hdr (bool): copy header from another SigprocFile class object Attributes: rawdatafile (str): Raw data file source_name (str): Source Name machine_id (int) : Machine ID barycentric (int): If 1 the data is barycentered pulsarcentric (int): Is the data in pulsar's frame of reference? src_raj (float): RA of the source (HHMMSS.SS) src_deg (float): Dec of the source (DDMMSS.SS) az_start (float): Telescope Azimuth (degrees) za_start (float): Telescope Zenith Angle (degrees) fch1 (float): Frequency of first channel (MHz)) foff (float): Channel bandwidth (MHz) nchans (int): Number of channels nbeams (int): Number of beams in the rcvr. ibeam (int): Beam number nbits (int): Number of bits the data are recorded in. tstart (float): Start MJD of the data tsamp (float): Sampling interval (seconds) nifs (int): Number of IFs in the data. get_data method SigprocFile . get_data ( nstart , nsamp , offset = 0 , pol = 0 ) Return nsamp time slices starting at nstart. Args: nstart (int): Starting spectra number to start reading from. nsamp (int): Number of spectra to read. offset (int): Can be used to offset reading from. pol (int): Which polarisation to read. Returns: numpy.ndarray: data. unpack method SigprocFile . unpack ( nstart , nsamp ) Unpack nsamp time slices starting at nstart to 32-bit floats. Args: nstart (int): Starting spectra number to start reading from. nsamp (int): Number of spectra to read. Returns: numpy.ndarray: Data write_header method SigprocFile . write_header ( filename ) Write the filterbank header Args: filename (str): name of the filterbank file append_spectra method SigprocFile . append_spectra ( spectra , filename ) Append spectra to the end of the file Args: spectra (numpy.ndarray) : numpy array of the data to be dumped into the filterbank file filename (str): name of the filterbank file","title":"filterbank"},{"location":"pysigproc/#sigprocfile-class","text":"your . pysigproc . SigprocFile ( fp = None , copy_hdr = None ) Simple functions for reading sigproc filterbank files from python. Not all possible features are implemented. Original Source from Paul Demorest's pysigproc.py . Args: fp (str): file name copy_hdr (bool): copy header from another SigprocFile class object Attributes: rawdatafile (str): Raw data file source_name (str): Source Name machine_id (int) : Machine ID barycentric (int): If 1 the data is barycentered pulsarcentric (int): Is the data in pulsar's frame of reference? src_raj (float): RA of the source (HHMMSS.SS) src_deg (float): Dec of the source (DDMMSS.SS) az_start (float): Telescope Azimuth (degrees) za_start (float): Telescope Zenith Angle (degrees) fch1 (float): Frequency of first channel (MHz)) foff (float): Channel bandwidth (MHz) nchans (int): Number of channels nbeams (int): Number of beams in the rcvr. ibeam (int): Beam number nbits (int): Number of bits the data are recorded in. tstart (float): Start MJD of the data tsamp (float): Sampling interval (seconds) nifs (int): Number of IFs in the data.","title":"SigprocFile class"},{"location":"pysigproc/#get_data-method","text":"SigprocFile . get_data ( nstart , nsamp , offset = 0 , pol = 0 ) Return nsamp time slices starting at nstart. Args: nstart (int): Starting spectra number to start reading from. nsamp (int): Number of spectra to read. offset (int): Can be used to offset reading from. pol (int): Which polarisation to read. Returns: numpy.ndarray: data.","title":"get_data method"},{"location":"pysigproc/#unpack-method","text":"SigprocFile . unpack ( nstart , nsamp ) Unpack nsamp time slices starting at nstart to 32-bit floats. Args: nstart (int): Starting spectra number to start reading from. nsamp (int): Number of spectra to read. Returns: numpy.ndarray: Data","title":"unpack method"},{"location":"pysigproc/#write_header-method","text":"SigprocFile . write_header ( filename ) Write the filterbank header Args: filename (str): name of the filterbank file","title":"write_header method"},{"location":"pysigproc/#append_spectra-method","text":"SigprocFile . append_spectra ( spectra , filename ) Append spectra to the end of the file Args: spectra (numpy.ndarray) : numpy array of the data to be dumped into the filterbank file filename (str): name of the filterbank file","title":"append_spectra method"},{"location":"your/","text":"Your class your . Your ( file ) Your class. Args: file : String or a list of files. It can either filterbank or psrfits files. Examples: your_object = your.Your(\"/path/to/filterbank.fil\") your_object = your.Your([\"puppi_58763_B1919+21_0292_0001.fits\",\"puppi_58763_B1919+21_0292_0002.fits\"] Attributes: isfits (bool): your object made from fits files isfil (bool) : your object makde from filterbank file your_header : instance of the Header class bandpass method Your . bandpass ( nspectra = None ) Create the bandpass of the file Args: nspectra (int): Number of spectra to create bandpass from. Returns: numpy.ndarray: bandpass array get_data method Your . get_data ( nstart , nsamp , time_decimation_factor = None , frequency_decimation_factor = None , pol = 0 ) Read data from files Args: nstart (int): start sample nsamp (int): number of samples to read time_decimation_factor (int): decimate in time with this factor frequency_decimation_factor (int): decimate in frequency with this factor pol (int): which polarization to chose Note: Both decimation factors should exactly device the nsamp or nchans Returns: numpy.ndarray: 2D numpy array of data dispersion_delay method Your . dispersion_delay ( dms = 5000 ) Calculate the dispersion delay in seconds for the given configuration Args: dms: DM or a list of DM values Returns: Dispersion delay in seconds. Header class your . Header ( your ) Your Header class, it contains all the relevant metadata. Args: Your object Attributes: filelist: List of files used to make the your object filename (str) : Name of the first file used to make the object basename (str): Base name of file source_name (str): Source Name ra_deg (float): RA of the source in degrees dec_deg (float): Dec of the source in degrees bw (float): bandwidth of the data center_freq (float): Center frequency of the data. time_decimation_factor (int): Number of time samples to average frequency_decimation_factor (int): Number of frequency channels to average native_tsamp (float): Sampling time of the data pre decimation (seconds) native_foff (float): Channel bandwidth of the data pre decimation (MHz) native_nchans : Number of channels in the data pre decimation native_nspectra: Number of spectra in the data pre decimation dtype: dtype of the (read) data nbits (int): Number of bits in the data tstart (float): Start MJD of the data fch1 (float): Frequency of the first channel (MHz) npol (int) : Number of polarisations in the data","title":"Core"},{"location":"your/#your-class","text":"your . Your ( file ) Your class. Args: file : String or a list of files. It can either filterbank or psrfits files. Examples: your_object = your.Your(\"/path/to/filterbank.fil\") your_object = your.Your([\"puppi_58763_B1919+21_0292_0001.fits\",\"puppi_58763_B1919+21_0292_0002.fits\"] Attributes: isfits (bool): your object made from fits files isfil (bool) : your object makde from filterbank file your_header : instance of the Header class","title":"Your class"},{"location":"your/#bandpass-method","text":"Your . bandpass ( nspectra = None ) Create the bandpass of the file Args: nspectra (int): Number of spectra to create bandpass from. Returns: numpy.ndarray: bandpass array","title":"bandpass method"},{"location":"your/#get_data-method","text":"Your . get_data ( nstart , nsamp , time_decimation_factor = None , frequency_decimation_factor = None , pol = 0 ) Read data from files Args: nstart (int): start sample nsamp (int): number of samples to read time_decimation_factor (int): decimate in time with this factor frequency_decimation_factor (int): decimate in frequency with this factor pol (int): which polarization to chose Note: Both decimation factors should exactly device the nsamp or nchans Returns: numpy.ndarray: 2D numpy array of data","title":"get_data method"},{"location":"your/#dispersion_delay-method","text":"Your . dispersion_delay ( dms = 5000 ) Calculate the dispersion delay in seconds for the given configuration Args: dms: DM or a list of DM values Returns: Dispersion delay in seconds.","title":"dispersion_delay method"},{"location":"your/#header-class","text":"your . Header ( your ) Your Header class, it contains all the relevant metadata. Args: Your object Attributes: filelist: List of files used to make the your object filename (str) : Name of the first file used to make the object basename (str): Base name of file source_name (str): Source Name ra_deg (float): RA of the source in degrees dec_deg (float): Dec of the source in degrees bw (float): bandwidth of the data center_freq (float): Center frequency of the data. time_decimation_factor (int): Number of time samples to average frequency_decimation_factor (int): Number of frequency channels to average native_tsamp (float): Sampling time of the data pre decimation (seconds) native_foff (float): Channel bandwidth of the data pre decimation (MHz) native_nchans : Number of channels in the data pre decimation native_nspectra: Number of spectra in the data pre decimation dtype: dtype of the (read) data nbits (int): Number of bits in the data tstart (float): Start MJD of the data fch1 (float): Frequency of the first channel (MHz) npol (int) : Number of polarisations in the data","title":"Header class"},{"location":"utils/astro/","text":"dec2deg function your . utils . astro . dec2deg ( src_dej ) Convert the SIGPROC-style DDMMSS.SSSS declination to degrees Args: src_dej (float): Source dec ra2deg function your . utils . astro . ra2deg ( src_raj ) Convert the SIGPROC-style HHMMSS.SSSS right ascension to degrees Args: src_raj (float): Source RA","title":"Astro"},{"location":"utils/astro/#dec2deg-function","text":"your . utils . astro . dec2deg ( src_dej ) Convert the SIGPROC-style DDMMSS.SSSS declination to degrees Args: src_dej (float): Source dec","title":"dec2deg function"},{"location":"utils/astro/#ra2deg-function","text":"your . utils . astro . ra2deg ( src_raj ) Convert the SIGPROC-style HHMMSS.SSSS right ascension to degrees Args: src_raj (float): Source RA","title":"ra2deg function"},{"location":"utils/gpu/","text":"gpu_dedisperse function your . utils . gpu . gpu_dedisperse ( cand , device = 0 ) GPU dedispersion (by rolling the array) Args: cand: Candidate instance device (int): GPU ID Returns: candidate object gpu_dmt function your . utils . gpu . gpu_dmt ( cand , device = 0 ) GPU DM-Time bow-tie (by rolling the array) Args: cand: Candidate instance device (int): GPU ID Returns: candidate object gpu_dedisp_and_dmt_crop function your . utils . gpu . gpu_dedisp_and_dmt_crop ( cand , device = 0 ) GPU based dedispersion, DM time bow-time plot and crop it to 256x256 shaped arrays (by rolling the array) Args: cand: Candidate instance device (int): GPU ID Returns: candidate object get_gpu_memory_map function your . utils . gpu . get_gpu_memory_map ( gpu_id ) Get the current gpu free memory Args: gpu_id (int): GPU id Returns: int: amount of free GPU RAM","title":"GPU"},{"location":"utils/gpu/#gpu_dedisperse-function","text":"your . utils . gpu . gpu_dedisperse ( cand , device = 0 ) GPU dedispersion (by rolling the array) Args: cand: Candidate instance device (int): GPU ID Returns: candidate object","title":"gpu_dedisperse function"},{"location":"utils/gpu/#gpu_dmt-function","text":"your . utils . gpu . gpu_dmt ( cand , device = 0 ) GPU DM-Time bow-tie (by rolling the array) Args: cand: Candidate instance device (int): GPU ID Returns: candidate object","title":"gpu_dmt function"},{"location":"utils/gpu/#gpu_dedisp_and_dmt_crop-function","text":"your . utils . gpu . gpu_dedisp_and_dmt_crop ( cand , device = 0 ) GPU based dedispersion, DM time bow-time plot and crop it to 256x256 shaped arrays (by rolling the array) Args: cand: Candidate instance device (int): GPU ID Returns: candidate object","title":"gpu_dedisp_and_dmt_crop function"},{"location":"utils/gpu/#get_gpu_memory_map-function","text":"your . utils . gpu . get_gpu_memory_map ( gpu_id ) Get the current gpu free memory Args: gpu_id (int): GPU id Returns: int: amount of free GPU RAM","title":"get_gpu_memory_map function"},{"location":"utils/heimdall/","text":"HeimdallManager class your . utils . heimdall . HeimdallManager ( dada_key = None , filename = None , verbosity = None , nsamps_gulp = 262144 , beam = None , baseline_length = 2 , output_dir = None , dm = None , dm_tol = 1.25 , zap_chans = None , max_giant_rate = None , dm_nbits = 32 , gpu_id = None , no_scrunching = False , rfi_tol = 5 , rfi_no_narrow = False , rfi_no_broad = False , boxcar_max = 4096 , fswap = None , min_tscrunch_width = None , ) So you want to run heimdall, here is wrapper class which will allow you to do just that. Args: dada_key (hex): use PSRDADA hexidecimal key filename (str): process specified SIGPROC filterbank file verbosity (str): v, V, g, G increase verbosity level nsamps_gulp (int): number of samples to be read at a time beam (int) : over-ride beam number baseline_length (float): number of seconds over which to smooth the baseline output_dir (str) : create all output files in specified path dm (list): min and max DM dm_tol (float): SNR loss tolerance between each DM trial zap_chans (int): zap all channels between start and end channels inclusive max_giant_rate (int): limit the maximum number of individual detections per minute to nevents dm_nbits (int): number of bits per sample in dedispersed time series gpu_id (int): run on specified GPU no_scrunching (bool): don't use an adaptive time scrunching during dedispersion rfi_tol (float): RFI exicision threshold limits rfi_no_narrow (bool): disable narrow band RFI excision rfi_no_broad (bool): disable 0-DM RFI excision boxcar_max (int): maximum boxcar width in samples fswap (bool): swap channel ordering for negative DM - SIGPROC 2,4 or 8 bit only min_tscrunch_width: vary between high quality (large value) and high performance (low value) run method HeimdallManager . run () Make the heimdall command and run it.","title":"Heimdall"},{"location":"utils/heimdall/#heimdallmanager-class","text":"your . utils . heimdall . HeimdallManager ( dada_key = None , filename = None , verbosity = None , nsamps_gulp = 262144 , beam = None , baseline_length = 2 , output_dir = None , dm = None , dm_tol = 1.25 , zap_chans = None , max_giant_rate = None , dm_nbits = 32 , gpu_id = None , no_scrunching = False , rfi_tol = 5 , rfi_no_narrow = False , rfi_no_broad = False , boxcar_max = 4096 , fswap = None , min_tscrunch_width = None , ) So you want to run heimdall, here is wrapper class which will allow you to do just that. Args: dada_key (hex): use PSRDADA hexidecimal key filename (str): process specified SIGPROC filterbank file verbosity (str): v, V, g, G increase verbosity level nsamps_gulp (int): number of samples to be read at a time beam (int) : over-ride beam number baseline_length (float): number of seconds over which to smooth the baseline output_dir (str) : create all output files in specified path dm (list): min and max DM dm_tol (float): SNR loss tolerance between each DM trial zap_chans (int): zap all channels between start and end channels inclusive max_giant_rate (int): limit the maximum number of individual detections per minute to nevents dm_nbits (int): number of bits per sample in dedispersed time series gpu_id (int): run on specified GPU no_scrunching (bool): don't use an adaptive time scrunching during dedispersion rfi_tol (float): RFI exicision threshold limits rfi_no_narrow (bool): disable narrow band RFI excision rfi_no_broad (bool): disable 0-DM RFI excision boxcar_max (int): maximum boxcar width in samples fswap (bool): swap channel ordering for negative DM - SIGPROC 2,4 or 8 bit only min_tscrunch_width: vary between high quality (large value) and high performance (low value)","title":"HeimdallManager class"},{"location":"utils/heimdall/#run-method","text":"HeimdallManager . run () Make the heimdall command and run it.","title":"run method"},{"location":"utils/math/","text":"closest_number function your . utils . math . closest_number ( big_num , small_num ) Finds the difference between the closest multiple of a smaller number with respect to a bigger number Args: big_num: The bigger number to find the closest of small_num: Number whose multiple is to be found and subtracted Returns: The difference between the closest multiple of a smaller number with respect to a bigger number primes function your . utils . math . primes ( n ) All the prime factors of a positive number Args: n: a positive number Returns: primes closest_divisor function your . utils . math . closest_divisor ( n , m ) Calculates the divisor of n, which is closest to (i.e bigger than) m Args: n: larger number of which divisor is to be found m: divisor closest to this number Returns: The divisor of n, which is closest to (i.e bigger than) m find_gcd function your . utils . math . find_gcd ( list_of_nos ) Greatest Common Divisor for a list of nos Args: list_of_nos: list of numbers Returns: GCD normalise function your . utils . math . normalise ( data ) Subtract median, divide by standard deviations Args: data (numpy.ndarray): data Returns: numpy.ndarray: normalised data smad_plotter function your . utils . math . smad_plotter ( freq_time , sigma = 5.0 , clip = True ) spectal Median Absolute Deviation clipper Args: freq_time: the frequency time data sigma (float): sigma at which to clip data clip (bool): if true replaces clips the data else replaces it with zeroes Returns: np.ndarray: clipped/flagged data","title":"Math"},{"location":"utils/math/#closest_number-function","text":"your . utils . math . closest_number ( big_num , small_num ) Finds the difference between the closest multiple of a smaller number with respect to a bigger number Args: big_num: The bigger number to find the closest of small_num: Number whose multiple is to be found and subtracted Returns: The difference between the closest multiple of a smaller number with respect to a bigger number","title":"closest_number function"},{"location":"utils/math/#primes-function","text":"your . utils . math . primes ( n ) All the prime factors of a positive number Args: n: a positive number Returns: primes","title":"primes function"},{"location":"utils/math/#closest_divisor-function","text":"your . utils . math . closest_divisor ( n , m ) Calculates the divisor of n, which is closest to (i.e bigger than) m Args: n: larger number of which divisor is to be found m: divisor closest to this number Returns: The divisor of n, which is closest to (i.e bigger than) m","title":"closest_divisor function"},{"location":"utils/math/#find_gcd-function","text":"your . utils . math . find_gcd ( list_of_nos ) Greatest Common Divisor for a list of nos Args: list_of_nos: list of numbers Returns: GCD","title":"find_gcd function"},{"location":"utils/math/#normalise-function","text":"your . utils . math . normalise ( data ) Subtract median, divide by standard deviations Args: data (numpy.ndarray): data Returns: numpy.ndarray: normalised data","title":"normalise function"},{"location":"utils/math/#smad_plotter-function","text":"your . utils . math . smad_plotter ( freq_time , sigma = 5.0 , clip = True ) spectal Median Absolute Deviation clipper Args: freq_time: the frequency time data sigma (float): sigma at which to clip data clip (bool): if true replaces clips the data else replaces it with zeroes Returns: np.ndarray: clipped/flagged data","title":"smad_plotter function"},{"location":"utils/misc/","text":"MyEncoder class your . utils . misc . MyEncoder ( * , skipkeys = False , ensure_ascii = True , check_circular = True , allow_nan = True , sort_keys = False , indent = None , separators = None , default = None ) Custom Encoder Class to convert any class to a JSON serializable object","title":"Misc"},{"location":"utils/misc/#myencoder-class","text":"your . utils . misc . MyEncoder ( * , skipkeys = False , ensure_ascii = True , check_circular = True , allow_nan = True , sort_keys = False , indent = None , separators = None , default = None ) Custom Encoder Class to convert any class to a JSON serializable object","title":"MyEncoder class"},{"location":"utils/plotter/","text":"figsize function your . utils . plotter . figsize ( scale , width_by_height_ratio ) Create figure size either a full page or a half page figure Args: scale (float): 0.5 for half page figure, 1 for full page width_by_height_ratio (float): ratio of width to height for the figure Returns: list: list of width and height get_params function your . utils . plotter . get_params ( scale = 0.5 , width_by_height_ratio = 1 ) Create a dictionary for pretty plotting Args: scale (float): 0.5 for half page figure, 1 for full page width_by_height_ratio (float): ratio of width to height for the figure Returns: dict: dictionary of parameters plot_h5 function your . utils . plotter . plot_h5 ( h5_file , save = True , detrend_ft = True , publication = False , mad_filter = False ) Plot the h5 candidates Args: mad_filter (int): use MAD filter to clip data h5_file (str): Name of the h5 file save (bool): Save the file as a png detrend_ft (bool): detrend the frequency time plot publication (bool): make publication quality plot Returns: None","title":"Plotter"},{"location":"utils/plotter/#figsize-function","text":"your . utils . plotter . figsize ( scale , width_by_height_ratio ) Create figure size either a full page or a half page figure Args: scale (float): 0.5 for half page figure, 1 for full page width_by_height_ratio (float): ratio of width to height for the figure Returns: list: list of width and height","title":"figsize function"},{"location":"utils/plotter/#get_params-function","text":"your . utils . plotter . get_params ( scale = 0.5 , width_by_height_ratio = 1 ) Create a dictionary for pretty plotting Args: scale (float): 0.5 for half page figure, 1 for full page width_by_height_ratio (float): ratio of width to height for the figure Returns: dict: dictionary of parameters","title":"get_params function"},{"location":"utils/plotter/#plot_h5-function","text":"your . utils . plotter . plot_h5 ( h5_file , save = True , detrend_ft = True , publication = False , mad_filter = False ) Plot the h5 candidates Args: mad_filter (int): use MAD filter to clip data h5_file (str): Name of the h5 file save (bool): Save the file as a png detrend_ft (bool): detrend the frequency time plot publication (bool): make publication quality plot Returns: None","title":"plot_h5 function"},{"location":"utils/rfi/","text":"savgol_filter function your . utils . rfi . savgol_filter ( data , foff , fw = 15 , sig = 6 ) Apply savgol filter to the data. See Agarwal el al. 2020 for details. Args: data (numpy.ndarray): bandpass of the data foff (float): channel bandwidth (MHz) fw (float): frequency window (MHz) sig (float): sigma value to apply cutoff on Returns: numpy.ndarray: mask for channels spectral_kurtosis function your . utils . rfi . spectral_kurtosis ( data , N = 1 , d = None ) Compute spectral kurtosis. See Nita et al. (2016) for details. Args: data (numpy.ndarray): 2D frequency time data N (int): Number of accumulations on the FPGA d (float): shape factor Returns: numpy.ndarray: Spectral Kurtosis along frequency axis","title":"RFI"},{"location":"utils/rfi/#savgol_filter-function","text":"your . utils . rfi . savgol_filter ( data , foff , fw = 15 , sig = 6 ) Apply savgol filter to the data. See Agarwal el al. 2020 for details. Args: data (numpy.ndarray): bandpass of the data foff (float): channel bandwidth (MHz) fw (float): frequency window (MHz) sig (float): sigma value to apply cutoff on Returns: numpy.ndarray: mask for channels","title":"savgol_filter function"},{"location":"utils/rfi/#spectral_kurtosis-function","text":"your . utils . rfi . spectral_kurtosis ( data , N = 1 , d = None ) Compute spectral kurtosis. See Nita et al. (2016) for details. Args: data (numpy.ndarray): 2D frequency time data N (int): Number of accumulations on the FPGA d (float): shape factor Returns: numpy.ndarray: Spectral Kurtosis along frequency axis","title":"spectral_kurtosis function"}]}